<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>首页</title>
    <url>/2022/05/09/index/</url>
    <content><![CDATA[<h2 id="欢迎各位的访问。"><a href="#欢迎各位的访问。" class="headerlink" title=" 欢迎各位的访问。"></a><center> 欢迎各位的访问。</center></h2>]]></content>
  </entry>
  <entry>
    <title>2022真实面试题整理</title>
    <url>/2022/05/31/2022%E7%9C%9F%E5%AE%9E%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="在一场面试中你会被问到什么取决于下面这些因素："><a href="#在一场面试中你会被问到什么取决于下面这些因素：" class="headerlink" title="在一场面试中你会被问到什么取决于下面这些因素："></a>在一场面试中你会被问到什么取决于下面这些因素：</h3><ul>
<li>你的经验</li>
<li>你的技术背景</li>
<li>你面试的职位</li>
<li>你面试的公司</li>
<li>运气<span id="more"></span>
<h3 id="explain各个字段代表的意思"><a href="#explain各个字段代表的意思" class="headerlink" title="explain各个字段代表的意思"></a>explain各个字段代表的意思</h3></li>
<li>id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li>
<li>select_type ：查询类型 或者是 其他操作类型</li>
<li>table ：正在访问哪个表</li>
<li>partitions ：匹配的分区</li>
<li>type ：访问的类型</li>
<li>possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</li>
<li>key ：实际使用到的索引，如果为NULL，则没有使用索引</li>
<li>key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
<li>ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li>
<li>rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</li>
<li>filtered ：查询的表行占表的百分比</li>
<li>Extra ：包含不适合在其它列中显示但十分重要的额外信息</li>
</ul>
<h3 id="mysql的锁"><a href="#mysql的锁" class="headerlink" title="mysql的锁"></a>mysql的锁</h3><h3 id="页面相应慢-从哪几方面入手处理"><a href="#页面相应慢-从哪几方面入手处理" class="headerlink" title="页面相应慢,从哪几方面入手处理"></a>页面相应慢,从哪几方面入手处理</h3><h3 id="大数据量之间同步-从哪几方面做优化处理-减少服务器及数据库压力"><a href="#大数据量之间同步-从哪几方面做优化处理-减少服务器及数据库压力" class="headerlink" title="大数据量之间同步,从哪几方面做优化处理 减少服务器及数据库压力"></a>大数据量之间同步,从哪几方面做优化处理 减少服务器及数据库压力</h3><h3 id="redis的几种集群模式及区别"><a href="#redis的几种集群模式及区别" class="headerlink" title="redis的几种集群模式及区别"></a>redis的几种集群模式及区别</h3><ul>
<li><a href="https://cloud.tencent.com/developer/article/1751001">https://cloud.tencent.com/developer/article/1751001</a></li>
<li><p>主从模式</p>
<ul>
<li>1个master，两个slave</li>
<li><p>主从复制的优缺点</p>
<ul>
<li>优点：<ul>
<li>读写分离</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</li>
<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li>
<li>难以支持在线扩容，Redis的容量受限于单机配置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哨兵模式</p>
<ul>
<li>一个master、两个slave、三个sentinel</li>
<li><p>哨兵模式的优缺点<br>  优点：</p>
<ul>
<li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li>
<li><p>哨兵模式下，master挂掉可以自动进行切换，系统可用性更高<br>缺点：</p>
</li>
<li><p>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</p>
</li>
<li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li>
</ul>
</li>
</ul>
</li>
<li>Cluster模式<ul>
<li>3主节点3从节点<h3 id="redis-为什么快"><a href="#redis-为什么快" class="headerlink" title="redis 为什么快"></a>redis 为什么快</h3></li>
</ul>
</li>
<li>完全基于内存，数据存在内存中</li>
<li>采用单线程，省去了很多上下文切换的时间以及CPU消耗</li>
<li>使用基于IO多路复用机制的线程模型，可以处理并发的链接<h3 id="mysql-和-redis-的双写问题"><a href="#mysql-和-redis-的双写问题" class="headerlink" title="mysql 和 redis 的双写问题:"></a>mysql 和 redis 的双写问题:</h3><ul>
<li>redis先写  写成功 mysql 没写成功</li>
<li>mysql 先写 redis 都没成功 数据库压力大 怎么解决<h3 id="dubbo-和-springcloud的区别"><a href="#dubbo-和-springcloud的区别" class="headerlink" title="dubbo 和 springcloud的区别?"></a>dubbo 和 springcloud的区别?</h3></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/7059400668036988964">https://juejin.cn/post/7059400668036988964</a></li>
<li><p>springcloud 不是一个开发框架，而是一整套的解决方案，而 dubbo 仅仅是一个 rpc 的框架。</p>
<ul>
<li>dubbo 采用的是传输层 tcp 协议，是二进制传输的，占用带宽较少，序列化采用的是 jdk 自带的序列化协议。springcloud 是应用层 http 协议，占用带宽比较多，同时 springcloud 采用的是 json 报文传输，消耗会比较大。</li>
<li>dubbo 调用使用的是长链接，适合传输数据量小的包，而对于 springcloud 是短连接，适合传输大数据量的信息，比如图片、文本之类的。</li>
<li>dubbo 开发需要依赖 jar 包，对依赖的管理比较复杂。springcloud 的接口协议比较松散，约束性不强。</li>
<li>关于 dubbo 和 springcloud 的提供的服务功能差异如下图所示：</li>
<li>| 功能名称 | Dubbo | spring cloud |<br>| —- | —-| —- |<br>| 服务注册中心 | ZooKeeper | Spring Cloud Netflix Eureka |<br>| 服务调用方式 | RPC | REST API |<br>| 服务网关 | 无 | Spring Cloud Netflix Zuul |<br>| 断路器 | 不完善 | Spring Cloud Netflix Hystrix|<br>| 分布式配置 | 无 | Spring Cloud Config|<br>| 服务跟踪 | 无 | Spring Cloud Sleuth |<br>| 消息总线 | 无 | Spring Cloud Bus|<br>| 数据流 | 无 | Spring Cloud Stream |<br>| 批量任务 | 无 | Spring Cloud Task |</li>
<li>注册中心使用的不同，dubbo 默认使用的是 zk, 而 springcloud 使用的注册中心为 eureka, 前者保证的是 cp ,而后者保证的是 ap, 但是随着 springcloud alibaba 的出现，又引入了 nacos 这样的神器，兼有注册中心和配置中心的功能<h3 id="什么是feign？它的优点是什么？"><a href="#什么是feign？它的优点是什么？" class="headerlink" title="什么是feign？它的优点是什么？"></a>什么是feign？它的优点是什么？</h3></li>
</ul>
<ol>
<li>feign采用的是基于接口的注解</li>
<li>feign整合了ribbon，具有负载均衡的能力</li>
<li>整合了Hystrix，具有熔断的能力</li>
</ol>
<ul>
<li>使用:</li>
</ul>
<ol>
<li>添加pom依赖。</li>
<li>启动类添加@EnableFeignClients</li>
<li>定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务<h3 id="zookeeper-和-eureka-的区别"><a href="#zookeeper-和-eureka-的区别" class="headerlink" title="zookeeper 和 eureka 的区别?"></a>zookeeper 和 eureka 的区别?</h3></li>
</ol>
<ul>
<li>CAP 理论 </li>
<li>eureka AP </li>
<li>zookeeper CP<h3 id="用没用过nacos-spring-cloud-如何使用的"><a href="#用没用过nacos-spring-cloud-如何使用的" class="headerlink" title="用没用过nacos , spring cloud 如何使用的 ?"></a>用没用过nacos , spring cloud 如何使用的 ?</h3><h3 id="spring-cloud-你用过那些组件"><a href="#spring-cloud-你用过那些组件" class="headerlink" title="spring cloud 你用过那些组件?"></a>spring cloud 你用过那些组件?</h3></li>
<li>Eureka （注册中心）</li>
<li>Zuul (服务网关)</li>
<li>Ribbon (负载均衡)</li>
<li>Hystrix （熔断保护器）隔离、熔断以及降级</li>
<li>Feign （Rest转换器）</li>
<li>Config （分布式配置管理）<h3 id="谈谈注册中心-zookeeper-和-eureka中的CP和-AP"><a href="#谈谈注册中心-zookeeper-和-eureka中的CP和-AP" class="headerlink" title="谈谈注册中心 zookeeper 和 eureka中的CP和 AP"></a>谈谈注册中心 zookeeper 和 eureka中的CP和 AP</h3></li>
</ul>
</li>
<li><p>eureka AP</p>
<ul>
<li><p>eureka 保证了可用性，实现最终一致性。</p>
</li>
<li><p>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)，其中说明了，eureka是不满足强一致性，但还是会保证最终一致性</p>
</li>
</ul>
</li>
<li><p>zookeeper CP</p>
<ul>
<li>zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用，但是在选举成功之后，因为一主多从的结构，zookeeper在这时还是一个高可用注册中心，只是在优先保证一致性的前提下，zookeeper才会顾及到可用性<h3 id="有多线程开发经验吗-了解过线程池吗-说一下线程池的使用"><a href="#有多线程开发经验吗-了解过线程池吗-说一下线程池的使用" class="headerlink" title="有多线程开发经验吗?了解过线程池吗,说一下线程池的使用"></a>有多线程开发经验吗?了解过线程池吗,说一下线程池的使用</h3></li>
<li>TreadPoolExecutor的7个参数</li>
</ul>
</li>
</ul>
<ol>
<li>corePoolSize </li>
<li>maximumPoolSize</li>
<li>keepAliveTime</li>
<li>unit</li>
<li>workQueue</li>
<li>threadFactory</li>
<li>handler<h3 id="gc-的回收原理"><a href="#gc-的回收原理" class="headerlink" title="gc 的回收原理"></a>gc 的回收原理</h3><ul>
<li>简述下gc 回收的过程便可。<h3 id="cms-和-G1-的主要区别"><a href="#cms-和-G1-的主要区别" class="headerlink" title="cms 和 G1 的主要区别?"></a>cms 和 G1 的主要区别?</h3></li>
<li>CMS收集器优点：、</li>
</ul>
</li>
</ol>
<ul>
<li>并发收集、低停顿。</li>
</ul>
<ul>
<li>CMS收集器缺点：<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage）。</li>
<li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li>
</ul>
</li>
<li><p>G1具备如下特点：</p>
<ul>
<li>并行与并发：<ul>
<li>G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</li>
</ul>
</li>
<li>分代收集<ul>
<li>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
</ul>
</li>
<li>可预测的停顿：<ul>
<li>这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。<h3 id="可达性分析算法-哪些对象可以作为GC-root"><a href="#可达性分析算法-哪些对象可以作为GC-root" class="headerlink" title="可达性分析算法 哪些对象可以作为GC root ?"></a>可达性分析算法 哪些对象可以作为GC root ?</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般说的Native方法）中引用的对象</li>
</ol>
<ul>
<li>JVM 原理的几大组成部分<h3 id="mysql-索引存储结构"><a href="#mysql-索引存储结构" class="headerlink" title="mysql 索引存储结构"></a>mysql 索引存储结构</h3><ul>
<li>b+tree<h3 id="spring-生命周期"><a href="#spring-生命周期" class="headerlink" title="spring 生命周期"></a>spring 生命周期</h3></li>
</ul>
</li>
<li>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁<h3 id="spring-bean的作用域"><a href="#spring-bean的作用域" class="headerlink" title="spring bean的作用域"></a>spring bean的作用域</h3></li>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局 session 作用域，<h3 id="一些技术点"><a href="#一些技术点" class="headerlink" title="一些技术点"></a>一些技术点</h3></li>
<li>nacos ： spring cloud alibaba 下的注册中心和配置中心 </li>
</ul>
<h2 id="RabbitMQ相关"><a href="#RabbitMQ相关" class="headerlink" title="RabbitMQ相关"></a>RabbitMQ相关</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>异步 : 比如发短信调用三方的接口，使用mq，发送到mq中就代表成功发送，不需要等待接口实时返回结果</li>
<li>解耦 ：系统A对接多个系统，不需要单独对接，只需要将需要对接的数据发送到mq中便可以，需要对接的系统自己去mq里消费便可以了。</li>
<li>流量削峰：某一时刻，系统并发量突然提高，这时候直接写库会造成数据库压力过大，在数据库和请求之间使用mq，将请求的数据直接发到mq中进行缓存，然后根据mq的队列顺序入库<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>系统可用性降低。</li>
<li>系统复杂度提高，随之带来几个问题<ul>
<li>怎么保证消息没有重复消费？</li>
<li>怎么处理消息丢失的情况？</li>
<li>保证消息传递的顺序性 ？<h3 id="主流MQ对比"><a href="#主流MQ对比" class="headerlink" title="主流MQ对比"></a>主流MQ对比</h3></li>
</ul>
</li>
<li>吞吐量<ul>
<li>kafka、RocketMQ高吞吐，ActiveMQ、RabbitMQ比他们低一个数量级。</li>
</ul>
</li>
<li>RabbitMQ是延迟最低的。</li>
<li>社区活跃度<ul>
<li>RabbitMQ 最高。</li>
</ul>
</li>
<li>持久化消息 ：ActiveMq 和RabbitMq 都支持<ul>
<li>持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</li>
</ul>
</li>
<li>综合技术实现<ul>
<li>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。RabbitMq 、 Kafka 最好，ActiveMq 次之</li>
</ul>
</li>
<li>高并发 <ul>
<li>RabbitMQ 最好，原因是它的实现语言是天生具备高并发高可用的erlang 语言。<h3 id="RabbitMQ-和-Kafka"><a href="#RabbitMQ-和-Kafka" class="headerlink" title="RabbitMQ 和 Kafka"></a>RabbitMQ 和 Kafka</h3></li>
</ul>
</li>
<li>在可用性上，稳定性上，可靠性上，RabbitMq 比 Kafka 成熟（理论上）。</li>
<li>Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件</li>
<li>业务方面还是建议选择 RabbitMq 。<h3 id="怎么解决消息重复消费问题？"><a href="#怎么解决消息重复消费问题？" class="headerlink" title="怎么解决消息重复消费问题？"></a>怎么解决消息重复消费问题？</h3></li>
<li>消费端解决，业务实现幂等性</li>
<li>生产端消息入队需要有消息的唯一ID（保单号，生产端发送消息并不能保证保单号唯一），</li>
<li>入库前根据唯一ID去数据库中校验是否存在，如果存在则不入库。否则入库。<ul>
<li>保单号，生产端发送消息并不能保证保单号唯一 带来的并发消费问题</li>
<li>解决方法使用redis 分布式锁，利用setnx特性，获取到锁后再进行入库。<h3 id="如何解决消息丢失问题？"><a href="#如何解决消息丢失问题？" class="headerlink" title="如何解决消息丢失问题？"></a>如何解决消息丢失问题？</h3><h4 id="生产者丢失数据"><a href="#生产者丢失数据" class="headerlink" title="生产者丢失数据"></a>生产者丢失数据</h4></li>
</ul>
</li>
<li>RabbitMQ 提供事务功能，就是生产者发送数据之前开启 RabbitMQ 事务。然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错。但吞吐量会降低，因为太耗性能（同步）。</li>
<li>开启confirm机制，每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，异步回调你，告诉你这个消息 ok 了。<ul>
<li>事务机制是同步的，confirm机制是异步的，发送个消息之后就可以发送下一个消息，RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。所以用confirm机制<h4 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h4></li>
</ul>
</li>
<li><p>RabbitMQ 自己挂掉导致数据丢失</p>
</li>
<li><p>开启 RabbitMQ 的持久化，消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据</p>
</li>
</ul>
<h4 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><ul>
<li><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
</li>
<li><p>关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>
</li>
<li></li>
</ul>
<h3 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h3><ul>
<li><p>消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。</p>
</li>
<li><p>消息体通过hash分派到队列里，每个队列对应唯一一个消费者。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：</p>
</li>
</ul>
<p><img src="https://github.com/xbox1994/Java-Interview/raw/master/images/消息顺序性.jpg" alt=""></p>
<ul>
<li>在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个订单号获取到的肯定是同一个队列。</li>
</ul>
<h2 id="JUC面试题"><a href="#JUC面试题" class="headerlink" title="JUC面试题"></a>JUC面试题</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><ul>
<li>一个程序里不同的执行路径<h3 id="线程的启动方式"><a href="#线程的启动方式" class="headerlink" title="线程的启动方式"></a>线程的启动方式</h3></li>
<li>继承thread 类 并调用start方法</li>
<li>实现Runable接口 然后通过new Thread（实现类）.start() 或 lambda 方法调用</li>
<li>通过线程池启动<h3 id="线程的集中等待的方式"><a href="#线程的集中等待的方式" class="headerlink" title="线程的集中等待的方式"></a>线程的集中等待的方式</h3></li>
<li>sleep 休眠一段时间，休眠结束后进入就绪态</li>
<li>yield 直接进入就绪态</li>
<li>join 将自身线程加入另一个线程，另一个线程结束后 直接运行自身这个线程。</li>
<li>wait 进入阻塞态，等待被叫醒，叫醒后进入就绪态。<h3 id="线程的六个状态？"><a href="#线程的六个状态？" class="headerlink" title="线程的六个状态？"></a>线程的六个状态？</h3></li>
<li>NEW 线程创建未执行</li>
<li>RUNNABLE 线程就绪或者执行</li>
<li>TERMINATED 线程正常结束</li>
<li>TIMEDWAITING  等待进入就绪的状态</li>
<li>WAITING 等待被叫醒的状态</li>
<li>BLOCKED 阻塞状态 等待获取锁。<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3></li>
<li>synchronized （this） 和 synchronized 方法其实是一样的</li>
<li>synchronized(Object) <ul>
<li>不能用String常量 Interger Long </li>
<li>object</li>
<li>锁的是对象 不是代码</li>
<li>this XX.class</li>
<li>锁升级 :  偏向锁、自旋锁、重量级锁（OS）—&gt; 是轻量到重量的一个过程<ul>
<li>执行时间短的用自旋锁</li>
<li>执行时间长的用重量级锁<h3 id="什么是并发？什么是并行？"><a href="#什么是并发？什么是并行？" class="headerlink" title="什么是并发？什么是并行？"></a>什么是并发？什么是并行？</h3></li>
</ul>
</li>
</ul>
</li>
<li>在固定时间内将多个线程平均分配该资源可以称为并发，每个线程执行是其余线程需要等待 简单说就是一个小时 12个学生 每五分钟一个学生可以向老师提问</li>
<li>并行就是在五分钟内 可以有多个学生同时向老师提问。</li>
<li>短的时间片叫并行。长时间片叫并发。<h3 id="并发与并行会造成什么影响？"><a href="#并发与并行会造成什么影响？" class="headerlink" title="并发与并行会造成什么影响？"></a>并发与并行会造成什么影响？</h3></li>
<li>死锁 ： 如何解决？ 答：保证同一时间只有一个线程可以处理当前事务，线程互斥。<h3 id="如何解决这些影响？"><a href="#如何解决这些影响？" class="headerlink" title="如何解决这些影响？"></a>如何解决这些影响？</h3></li>
<li>管程（程序管理）</li>
<li>加锁<h3 id="操作系统基本概念说一下"><a href="#操作系统基本概念说一下" class="headerlink" title="操作系统基本概念说一下?"></a>操作系统基本概念说一下?</h3></li>
<li>finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 Java中所有类都从Object类中继承finalize()方法。 当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法</li>
</ul>
<h3 id="volatile-只针对变量"><a href="#volatile-只针对变量" class="headerlink" title="volatile 只针对变量"></a>volatile 只针对变量</h3><ul>
<li>可以解决操作系统重排序<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象地址赋值给引用</li>
</ul>
</li>
<li>解决线程共享变量之间的可见性</li>
<li>解决单次读/写的原子性</li>
<li>AQS</li>
<li>CAS : 并发包 atomic包下的包装类运用的cas机制  </li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>自控力</title>
    <url>/2022/05/27/%E8%87%AA%E6%8E%A7%E5%8A%9B/</url>
    <content><![CDATA[<h2 id="自控力"><a href="#自控力" class="headerlink" title="自控力"></a>自控力</h2><h3 id="凯利-麦格尼格尔"><a href="#凯利-麦格尼格尔" class="headerlink" title="凯利.麦格尼格尔"></a>凯利.麦格尼格尔</h3><h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><blockquote>
<h4 id="为了成功做到自控，你必须知道自己为何失败"><a href="#为了成功做到自控，你必须知道自己为何失败" class="headerlink" title="为了成功做到自控，你必须知道自己为何失败"></a>为了成功做到自控，你必须知道自己为何失败</h4><blockquote>
<h5 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h5><ul>
<li>谈了一下自控力的重要性<h4 id="如何运用本书"><a href="#如何运用本书" class="headerlink" title="如何运用本书"></a>如何运用本书</h4><h5 id="自我总结：-1"><a href="#自我总结：-1" class="headerlink" title="自我总结："></a>自我总结：</h5></li>
<li>简述了一下本书的作用<h3 id="第一篇：我要做，我不做，我想要：什么是意志力？为什么意志力至关重要？"><a href="#第一篇：我要做，我不做，我想要：什么是意志力？为什么意志力至关重要？" class="headerlink" title="第一篇：我要做，我不做，我想要：什么是意志力？为什么意志力至关重要？"></a>第一篇：我要做，我不做，我想要：什么是意志力？为什么意志力至关重要？</h3><h4 id="我们为什么会有意志力？"><a href="#我们为什么会有意志力？" class="headerlink" title="我们为什么会有意志力？"></a>我们为什么会有意志力？</h4><h4 id="“我要做”-“我不要”-和-“我想要”-的神经学原理"><a href="#“我要做”-“我不要”-和-“我想要”-的神经学原理" class="headerlink" title="“我要做” “我不要” 和 “我想要” 的神经学原理"></a>“我要做” “我不要” 和 “我想要” 的神经学原理</h4><h4 id="两个自我导致的问题"><a href="#两个自我导致的问题" class="headerlink" title="两个自我导致的问题"></a>两个自我导致的问题</h4><h4 id="训练大脑，增强意志力"><a href="#训练大脑，增强意志力" class="headerlink" title="训练大脑，增强意志力"></a>训练大脑，增强意志力</h4><h3 id="第二篇：意志力的本能：人生本来就能地址奶酪蛋糕的诱惑"><a href="#第二篇：意志力的本能：人生本来就能地址奶酪蛋糕的诱惑" class="headerlink" title="第二篇：意志力的本能：人生本来就能地址奶酪蛋糕的诱惑"></a>第二篇：意志力的本能：人生本来就能地址奶酪蛋糕的诱惑</h3><h4 id="两种不同的威胁"><a href="#两种不同的威胁" class="headerlink" title="两种不同的威胁"></a>两种不同的威胁</h4><h4 id="意志力的本能：三思而后行"><a href="#意志力的本能：三思而后行" class="headerlink" title="意志力的本能：三思而后行"></a>意志力的本能：三思而后行</h4><h4 id="训练你的身心"><a href="#训练你的身心" class="headerlink" title="训练你的身心"></a>训练你的身心</h4><h4 id="自控力太强的代价"><a href="#自控力太强的代价" class="headerlink" title="自控力太强的代价"></a>自控力太强的代价</h4><h4 id="充满压力的过度"><a href="#充满压力的过度" class="headerlink" title="充满压力的过度"></a>充满压力的过度</h4><h3 id="第三篇：累到无力抵抗：为什么自控力和肌肉一样有极限"><a href="#第三篇：累到无力抵抗：为什么自控力和肌肉一样有极限" class="headerlink" title="第三篇：累到无力抵抗：为什么自控力和肌肉一样有极限"></a>第三篇：累到无力抵抗：为什么自控力和肌肉一样有极限</h3><h4 id="自控的肌肉模式"><a href="#自控的肌肉模式" class="headerlink" title="自控的肌肉模式"></a>自控的肌肉模式</h4><h4 id="为什么自控力存在局限？"><a href="#为什么自控力存在局限？" class="headerlink" title="为什么自控力存在局限？"></a>为什么自控力存在局限？</h4><h4 id="训练-“意志力肌肉”"><a href="#训练-“意志力肌肉”" class="headerlink" title="训练 “意志力肌肉”"></a>训练 “意志力肌肉”</h4><h4 id="自控力是否真的有-“极限”？"><a href="#自控力是否真的有-“极限”？" class="headerlink" title="自控力是否真的有 “极限”？"></a>自控力是否真的有 “极限”？</h4><h4 id="日常消耗和文明毁灭"><a href="#日常消耗和文明毁灭" class="headerlink" title="日常消耗和文明毁灭"></a>日常消耗和文明毁灭</h4><h3 id="第四篇：容忍罪恶：为何善行之后会有恶行"><a href="#第四篇：容忍罪恶：为何善行之后会有恶行" class="headerlink" title="第四篇：容忍罪恶：为何善行之后会有恶行"></a>第四篇：容忍罪恶：为何善行之后会有恶行</h3><h4 id="从圣人到罪人"><a href="#从圣人到罪人" class="headerlink" title="从圣人到罪人"></a>从圣人到罪人</h4><h4 id="关于进步的问题"><a href="#关于进步的问题" class="headerlink" title="关于进步的问题"></a>关于进步的问题</h4><h4 id="今天犯错，明天补救"><a href="#今天犯错，明天补救" class="headerlink" title="今天犯错，明天补救"></a>今天犯错，明天补救</h4><h4 id="当罪恶看起来像美德"><a href="#当罪恶看起来像美德" class="headerlink" title="当罪恶看起来像美德"></a>当罪恶看起来像美德</h4><h4 id="环保的危害"><a href="#环保的危害" class="headerlink" title="环保的危害"></a>环保的危害</h4><h3 id="第五篇：大脑的弥天大谎：为什么我们误把渴望当幸福"><a href="#第五篇：大脑的弥天大谎：为什么我们误把渴望当幸福" class="headerlink" title="第五篇：大脑的弥天大谎：为什么我们误把渴望当幸福"></a>第五篇：大脑的弥天大谎：为什么我们误把渴望当幸福</h3><h4 id="奖励的承诺"><a href="#奖励的承诺" class="headerlink" title="奖励的承诺"></a>奖励的承诺</h4><h4 id="“我想要”-的神经生物学原理"><a href="#“我想要”-的神经生物学原理" class="headerlink" title="“我想要” 的神经生物学原理"></a>“我想要” 的神经生物学原理</h4><h4 id="分泌多巴胺的大脑：神经营销学的崛起"><a href="#分泌多巴胺的大脑：神经营销学的崛起" class="headerlink" title="分泌多巴胺的大脑：神经营销学的崛起"></a>分泌多巴胺的大脑：神经营销学的崛起</h4><h4 id="让多巴胺发挥作用"><a href="#让多巴胺发挥作用" class="headerlink" title="让多巴胺发挥作用"></a>让多巴胺发挥作用</h4><h4 id="多巴胺的阴暗面"><a href="#多巴胺的阴暗面" class="headerlink" title="多巴胺的阴暗面"></a>多巴胺的阴暗面</h4><h4 id="欲望的重要性"><a href="#欲望的重要性" class="headerlink" title="欲望的重要性"></a>欲望的重要性</h4><h3 id="第六篇：“那又如何”：情绪低落为何会使人屈服于诱惑？"><a href="#第六篇：“那又如何”：情绪低落为何会使人屈服于诱惑？" class="headerlink" title="第六篇：“那又如何”：情绪低落为何会使人屈服于诱惑？"></a>第六篇：“那又如何”：情绪低落为何会使人屈服于诱惑？</h3><h4 id="为什么压力会勾起欲望？"><a href="#为什么压力会勾起欲望？" class="headerlink" title="为什么压力会勾起欲望？"></a>为什么压力会勾起欲望？</h4><h4 id="如果你吃了这快饼干，恐怖分子就赢了"><a href="#如果你吃了这快饼干，恐怖分子就赢了" class="headerlink" title="如果你吃了这快饼干，恐怖分子就赢了"></a>如果你吃了这快饼干，恐怖分子就赢了</h4><h4 id="“那又如何”效应：为什么罪恶感不起作用？"><a href="#“那又如何”效应：为什么罪恶感不起作用？" class="headerlink" title="“那又如何”效应：为什么罪恶感不起作用？"></a>“那又如何”效应：为什么罪恶感不起作用？</h4><h4 id="决定改善心情"><a href="#决定改善心情" class="headerlink" title="决定改善心情"></a>决定改善心情</h4><h3 id="第七篇：出售未来：及时享乐的经济学"><a href="#第七篇：出售未来：及时享乐的经济学" class="headerlink" title="第七篇：出售未来：及时享乐的经济学"></a>第七篇：出售未来：及时享乐的经济学</h3><h4 id="出售未来"><a href="#出售未来" class="headerlink" title="出售未来"></a>出售未来</h4><h4 id="没有出路：预先承诺的价值"><a href="#没有出路：预先承诺的价值" class="headerlink" title="没有出路：预先承诺的价值"></a>没有出路：预先承诺的价值</h4><h4 id="遇见未来的自己"><a href="#遇见未来的自己" class="headerlink" title="遇见未来的自己"></a>遇见未来的自己</h4><h4 id="该等待的时候，该屈服的时候"><a href="#该等待的时候，该屈服的时候" class="headerlink" title="该等待的时候，该屈服的时候"></a>该等待的时候，该屈服的时候</h4><h3 id="第八篇：传染：为什么意志力会传染？"><a href="#第八篇：传染：为什么意志力会传染？" class="headerlink" title="第八篇：传染：为什么意志力会传染？"></a>第八篇：传染：为什么意志力会传染？</h3><h4 id="传染病的传播"><a href="#传染病的传播" class="headerlink" title="传染病的传播"></a>传染病的传播</h4><h4 id="社会中的个人"><a href="#社会中的个人" class="headerlink" title="社会中的个人"></a>社会中的个人</h4><h4 id="群体的一员"><a href="#群体的一员" class="headerlink" title="群体的一员"></a>群体的一员</h4><h4 id="“我应该”-的力量"><a href="#“我应该”-的力量" class="headerlink" title="“我应该” 的力量"></a>“我应该” 的力量</h4><h3 id="第九篇：别读这章：“我不要”-力量的局限性"><a href="#第九篇：别读这章：“我不要”-力量的局限性" class="headerlink" title="第九篇：别读这章：“我不要” 力量的局限性"></a>第九篇：别读这章：“我不要” 力量的局限性</h3><h4 id="这难道不讽刺吗？"><a href="#这难道不讽刺吗？" class="headerlink" title="这难道不讽刺吗？"></a>这难道不讽刺吗？</h4><h4 id="我不想有这种感觉"><a href="#我不想有这种感觉" class="headerlink" title="我不想有这种感觉"></a>我不想有这种感觉</h4><h4 id="别吃那个苹果"><a href="#别吃那个苹果" class="headerlink" title="别吃那个苹果"></a>别吃那个苹果</h4><h4 id="请勿吸烟"><a href="#请勿吸烟" class="headerlink" title="请勿吸烟"></a>请勿吸烟</h4><h4 id="对内自我接受，对外控制行动"><a href="#对内自我接受，对外控制行动" class="headerlink" title="对内自我接受，对外控制行动"></a>对内自我接受，对外控制行动</h4><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3></li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2022/05/27/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h2 id="如何阅读一本书"><a href="#如何阅读一本书" class="headerlink" title="如何阅读一本书"></a>如何阅读一本书</h2><h3 id="莫提默·艾德勒-查尔斯·范多伦"><a href="#莫提默·艾德勒-查尔斯·范多伦" class="headerlink" title="莫提默·艾德勒 查尔斯·范多伦"></a>莫提默·艾德勒 查尔斯·范多伦</h3><h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h3 id="第一篇-阅读的层次"><a href="#第一篇-阅读的层次" class="headerlink" title="第一篇 阅读的层次"></a>第一篇 阅读的层次</h3><blockquote>
<h4 id="第一章-阅读的活力与艺术"><a href="#第一章-阅读的活力与艺术" class="headerlink" title="第一章 阅读的活力与艺术"></a>第一章 阅读的活力与艺术</h4><blockquote>
<h5 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h5><ul>
<li>简单阐述一下阅读的重要性嘛<h5 id="摘抄及想法"><a href="#摘抄及想法" class="headerlink" title="摘抄及想法:"></a>摘抄及想法:</h5></li>
<li>阅读是思考的过程这是经由研究、调查或在无人指导的状况下，自己深思熟虑的一种学习过程</li>
<li>不要对学习的方式产生偏见，被引导和自我发现都是主动学习。不论是哪一种方式，只有真正学习到的人才是主动的学习者</li>
<li>当他被指导时——在老师的帮助下自我发现时——学习者的行动立足于传达给他的讯息</li>
<li>立足于对自然及这个世界的理解。当学习者在没有任何老师指导帮助下开始学习时，学习者则是立足于自然或世界，而不是教导来行动</li>
<li>当学习者在没有任何老师指导帮助下开始学习时，学习者则是立足于自然或世界，而不是教导来行动</li>
<li>简单地说，阅读的艺术包括了所有非辅助型自我发现学习的技巧：敏锐的观察、灵敏可靠的记忆、想象的空间，再者当然就是训练有素的分析、省思能力<h4 id="第二章-阅读的层次"><a href="#第二章-阅读的层次" class="headerlink" title="第二章 阅读的层次"></a>第二章 阅读的层次</h4><h5 id="自我总结：-1"><a href="#自我总结：-1" class="headerlink" title="自我总结："></a>自我总结：</h5></li>
<li>简述阐述一下阅读的四个层次：基础阅读、检视阅读、分析阅读、主题阅读<h5 id="摘抄及想法-1"><a href="#摘抄及想法-1" class="headerlink" title="摘抄及想法:"></a>摘抄及想法:</h5>主题阅读：感觉更像是现在博客分析一个技术点一样的东西，通过各种资料对一个技术点的查阅，从而总结出自己对该技术点的理解<h4 id="第三章-阅读的第一个层次：基础阅读"><a href="#第三章-阅读的第一个层次：基础阅读" class="headerlink" title="第三章 阅读的第一个层次：基础阅读"></a>第三章 阅读的第一个层次：基础阅读</h4><h4 id="自我总结：-2"><a href="#自我总结：-2" class="headerlink" title="自我总结："></a>自我总结：</h4></li>
<li>围绕基础阅读来详细展开说明其是什么，怎么做。<h5 id="摘抄及想法："><a href="#摘抄及想法：" class="headerlink" title="摘抄及想法："></a>摘抄及想法：</h5></li>
<li>为什么？要教育少数具有高度学习动机的孩子阅读（通常他们的父母都是知识分子），和教育一些不管动机有多微弱，或家庭有多贫困的孩子阅读，是完全不同的两码事</li>
<li>阅读准备阶段</li>
<li>读一些简单的读物</li>
<li>快速建立字汇的能力</li>
<li>精练与增进前面所学的技巧<h4 id="第四章-阅读的第二个层次：检视阅读"><a href="#第四章-阅读的第二个层次：检视阅读" class="headerlink" title="第四章 阅读的第二个层次：检视阅读"></a>第四章 阅读的第二个层次：检视阅读</h4><h5 id="自我总结：-3"><a href="#自我总结：-3" class="headerlink" title="自我总结："></a>自我总结：</h5></li>
<li>简答说就是用快速的阅读来基本了解本书的内容借架构，方便分析阅读。<h5 id="摘抄及想法：-1"><a href="#摘抄及想法：-1" class="headerlink" title="摘抄及想法："></a>摘抄及想法：</h5></li>
<li>谨记不要被一个看不懂的章节、注解、评论或参考资料阻挠或泄气</li>
<li>不要被一个看不懂的章节、注解、评论或参考资料阻挠或泄气</li>
<li>要记住我们阅读的目的, 每个阅读阶段有不同的目的。我们大多数人所受的教育，都说是要去注意那些我们不懂的地方。我们被教导说，碰到生字，就去查字典。我们被教导说，读到一些不明白的隐喻或论说，就去查百科全书或其他相关资料。我们被教导说，要去查注脚、学者的注释或其他的二手资料以获得帮助。但是如果时候不到就做这些事，却只会妨碍我们的阅读，而非帮助。</li>
<li>根据自己的理解程度和书本的重要程度来阅读以及记忆。依照读物的性质与复杂程度，而让你用不同的速度来阅读。<h4 id="第五章-如何做一个自我要求的读者"><a href="#第五章-如何做一个自我要求的读者" class="headerlink" title="第五章 如何做一个自我要求的读者"></a>第五章 如何做一个自我要求的读者</h4><h5 id="自我总结：-4"><a href="#自我总结：-4" class="headerlink" title="自我总结："></a>自我总结：</h5></li>
<li>读一本书我们需要做的、思考的一些东西，以及相关的一些概念<h5 id="摘抄及想法：-2"><a href="#摘抄及想法：-2" class="headerlink" title="摘抄及想法："></a>摘抄及想法：</h5></li>
<li>关于一本书，你一定要提出四个主要的问题</li>
<li>整体来说，这本书到底在谈些什么？</li>
<li>作者细部说了什么，怎么说的？</li>
<li>这本书说得有道理吗？</li>
<li>这本书跟你有什么关系？</li>
<li>技巧的提升会提高自己阅读的能力。不全是懒惰的错，技巧的缺失也是我们需要重视的地方。并不是起身的本身在让你疲倦，而是因为你欠缺有效运用自我提升的技巧，在挫败中产生了沮丧，因而才感到厌倦。要保持主动的阅读，你不只是要有意愿这么做而已，还要有技巧——能战胜最初觉得自己能力不足部分，进而自我提升的艺术。</li>
<li>提出问题</li>
<li>试着去回答问题</li>
<li>在书上做笔记是不可或缺的事？</li>
<li>保持清醒那会让你保持清醒</li>
<li>那会让你保持清醒</li>
<li>主动思考与表达阅读，如果是主动的，就是一种思考，而思考倾向于用语言表达出来——不管是用讲的还是写的</li>
<li>阅读，如果是主动的，就是一种思考，而思考倾向于用语言表达出来——不管是用讲的还是写的</li>
<li>方便记忆将你的感想写下来，能帮助你记住作者的思想</li>
<li>将你的感想写下来，能帮助你记住作者的思想</li>
<li>我目前已经做到了画底线——在主要的重点，或重要又有力量的句子下画线</li>
<li>双重强调，在微信读书中我可以选择波浪线在画底线处的栏外再加画一道线——把你已经画线的部分再强调一遍，或是某一段很重要，但要画底线太长了，便在这一整段外加上一个记号</li>
<li>可以利用微信读书的想法功能来进行总结在空白处编号——作者的某个论点发展出一连串的重要陈述时，可以做顺序编号。</li>
<li>可以用想法进行记录在空白处记下其他的页码</li>
<li>将关键字或句子圈出来</li>
<li>在书页的空白处做笔记</li>
<li>想法功能在书页的空白处做笔记</li>
<li>第一，这是什么样的一本书？第二，整本书在谈的是什么？第三，作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？</li>
<li>结构笔记、概念笔记、辩证笔记</li>
<li>最难是开始，开始之后是复杂的分开的技巧，然后是融会贯通。一开始时，学习者只会注意到自己与那些分开来的动作。等所有分开的动作不再分离，渐渐融为一体时，学习者便能将注意力转移到目标上，而他也具备了要达成目标的能力了。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="第二篇-阅读的第三个层次：分析阅读"><a href="#第二篇-阅读的第三个层次：分析阅读" class="headerlink" title="第二篇 阅读的第三个层次：分析阅读"></a>第二篇 阅读的第三个层次：分析阅读</h3><blockquote>
<h4 id="第六章：一本书的分类"><a href="#第六章：一本书的分类" class="headerlink" title="第六章：一本书的分类"></a>第六章：一本书的分类</h4><blockquote>
<h5 id="自我总结：-5"><a href="#自我总结：-5" class="headerlink" title="自我总结："></a>自我总结：</h5><ul>
<li>主要讲述: 书名分类;实用性和理论性的分类; 理论性下的分类<h5 id="摘抄及想法：-3"><a href="#摘抄及想法：-3" class="headerlink" title="摘抄及想法："></a>摘抄及想法：</h5></li>
<li>书名有时会让书籍的分类变得比较容易一些</li>
<li>先认真思考书名；思考这本书在讲什么再强调一次，光是将书籍分类到某一个种类中还是不够的。要跟随第一个阅读步骤，你一定要知道这个种类的书到底是在谈些什么</li>
<li>再强调一次，光是将书籍分类到某一个种类中还是不够的。要跟随第一个阅读步骤，你一定要知道这个种类的书到底是在谈些什么</li>
<li>虚构小说；传达知识的论说类书籍 1. 历史书；2. 哲学书；3. 科学；4. 数学 ….</li>
<li>我们已经粗略地谈过书籍的分类了。我们说过，主要的分类法，一种是虚构的小说类，另一种是传达知识，说明性的论说类。在论说性的书籍中，我们可以更进一步将历史从哲学中分类出来，也可以将这二者从科学与数学中区分出来。</li>
<li>要让知识变成实用，就要有操作的规则</li>
<li>照传统的分法，理论性的作品会被分类为历史、科学和哲学等等</li>
<li>历史就是纪事</li>
<li>科学则不会太在意过去的事，它所面对的是可能发生在任何时间、地点的事</li>
<li>哲学比较像科学，不像历史，追求的是一般的真理，而非发生在过去的特定事件，不管那个过去是近代或较远的年代</li>
<li>如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书</li>
<li>我在哲学的学习路上哲学家却会以人类的共通性作例证。</li>
<li>哲学家却会以人类的共通性作例证。<h4 id="第七章：透视一本书"><a href="#第七章：透视一本书" class="headerlink" title="第七章：透视一本书"></a>第七章：透视一本书</h4><h5 id="自我总结：-6"><a href="#自我总结：-6" class="headerlink" title="自我总结："></a>自我总结：</h5></li>
<li>待总结<h5 id="摘抄及想法：-4"><a href="#摘抄及想法：-4" class="headerlink" title="摘抄及想法："></a>摘抄及想法：</h5></li>
<li>第一个规则：给书籍归类；</li>
<li>第二个规则：简述这本书讲了什么分析阅读的第二个规则是：使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。</li>
<li>重要骨架的罗列第三个规则可以说成是：将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。</li>
<li>一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。每个重要部分都要有一定的独立性。</li>
<li><p>这也算写书的技巧了吧一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。每个重要部分都要有一定的独立性。</p>
</li>
<li><p>这个规则要求我们将一本书最重要的部分照秩序与关系，列举出来。这是第三个规则</p>
</li>
<li>根据大纲目录做读书笔记（1）作者将全书分成五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分又是另一些事。（2）第一个主要的部分又分成三个段落，第一段落为X，第二段落为Y，第三段落为Z。（3）在第一部分的第一阶段，作者有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。<h4 id="第八章：与作者找出共通的词义"><a href="#第八章：与作者找出共通的词义" class="headerlink" title="第八章：与作者找出共通的词义"></a>第八章：与作者找出共通的词义</h4><h4 id="第九章：判断作者的主旨"><a href="#第九章：判断作者的主旨" class="headerlink" title="第九章：判断作者的主旨"></a>第九章：判断作者的主旨</h4><h4 id="第十章：公正地评断一本书"><a href="#第十章：公正地评断一本书" class="headerlink" title="第十章：公正地评断一本书"></a>第十章：公正地评断一本书</h4><h4 id="第十一章：赞同或反对作者"><a href="#第十一章：赞同或反对作者" class="headerlink" title="第十一章：赞同或反对作者"></a>第十一章：赞同或反对作者</h4><h4 id="第二十章：辅助阅读"><a href="#第二十章：辅助阅读" class="headerlink" title="第二十章：辅助阅读"></a>第二十章：辅助阅读</h4><h3 id="第三篇-阅读不同读物的方法"><a href="#第三篇-阅读不同读物的方法" class="headerlink" title="第三篇 阅读不同读物的方法"></a>第三篇 阅读不同读物的方法</h3><h4 id="第十三章：如何阅读实用型的书"><a href="#第十三章：如何阅读实用型的书" class="headerlink" title="第十三章：如何阅读实用型的书"></a>第十三章：如何阅读实用型的书</h4><h4 id="第十四章：如何阅读想象文学"><a href="#第十四章：如何阅读想象文学" class="headerlink" title="第十四章：如何阅读想象文学"></a>第十四章：如何阅读想象文学</h4><h4 id="第十五章：阅读故事、戏剧与诗的一些建议"><a href="#第十五章：阅读故事、戏剧与诗的一些建议" class="headerlink" title="第十五章：阅读故事、戏剧与诗的一些建议"></a>第十五章：阅读故事、戏剧与诗的一些建议</h4><h4 id="第十六章：如何阅读历史书"><a href="#第十六章：如何阅读历史书" class="headerlink" title="第十六章：如何阅读历史书"></a>第十六章：如何阅读历史书</h4><h4 id="第十七章：如何阅读科学与数学"><a href="#第十七章：如何阅读科学与数学" class="headerlink" title="第十七章：如何阅读科学与数学"></a>第十七章：如何阅读科学与数学</h4><h4 id="第十八章：如何阅读哲学书"><a href="#第十八章：如何阅读哲学书" class="headerlink" title="第十八章：如何阅读哲学书"></a>第十八章：如何阅读哲学书</h4><h4 id="第十九章：如何阅读社会科学"><a href="#第十九章：如何阅读社会科学" class="headerlink" title="第十九章：如何阅读社会科学"></a>第十九章：如何阅读社会科学</h4><h3 id="第四篇-阅读的最终目标"><a href="#第四篇-阅读的最终目标" class="headerlink" title="第四篇 阅读的最终目标"></a>第四篇 阅读的最终目标</h3><h4 id="第二十章：阅读的第四个层次：主题阅读"><a href="#第二十章：阅读的第四个层次：主题阅读" class="headerlink" title="第二十章：阅读的第四个层次：主题阅读"></a>第二十章：阅读的第四个层次：主题阅读</h4><h4 id="第二十一章：阅读与心智的成长"><a href="#第二十一章：阅读与心智的成长" class="headerlink" title="第二十一章：阅读与心智的成长"></a>第二十一章：阅读与心智的成长</h4></li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>工作</title>
    <url>/2022/05/11/obe%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="工作日志"><a href="#工作日志" class="headerlink" title="工作日志 "></a><center>工作日志 </center></h1><h2 id="OBE-工作日志"><a href="#OBE-工作日志" class="headerlink" title="OBE 工作日志"></a><center>OBE 工作日志</center></h2><span id="more"></span>
<h3 id="达成目标"><a href="#达成目标" class="headerlink" title="达成目标"></a>达成目标</h3><ul>
<li>将人才培养模块熟悉并调试</li>
<li>整理调试过程中遇到的问题</li>
<li>整理obe项目数据流向<h3 id="问题或建议"><a href="#问题或建议" class="headerlink" title="问题或建议"></a>问题或建议</h3></li>
</ul>
<ol>
<li>支持筛选学院，但列表为展示学院信息。<br><img src="https://imgur.com/NpLknDT.png" alt=""></li>
<li>人陪信息-所属专业保存不成功  (默认是测试专业)</li>
<li>同时修改多个培养目标，只保存最后一个修改过的</li>
<li>课程体系接口有点慢</li>
<li>毕业条件接口存在循环调用问题</li>
<li>课程体系查询存在重复查询问题 planCode = PL202204071119520566</li>
<li>提交毕业要求接口（/graduate/status/）权重配置错误的情况 未正确返回提示。</li>
<li>基本信息课程下拉double 需要改进<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3></li>
<li>为什么直接用name查询，不用code进行查询</li>
</ol>
<h3 id="页面及相关表"><a href="#页面及相关表" class="headerlink" title="页面及相关表"></a>页面及相关表</h3><h4 id="人才培养方案"><a href="#人才培养方案" class="headerlink" title="人才培养方案"></a>人才培养方案</h4><ul>
<li>人才培养方案列表   <pre> /plans : obe_cultivation_plan (人陪表) </pre></li>
<li>删除人陪信息   <pre> /plan/delete : obe_cultivation_plan</pre></li>
<li>提交审核   <pre> /plan/auditing/{planCode} : obe_cultivation_plan</pre></li>
<li>人才方案撰写: <ul>
<li>人陪信息 <ul>
<li>保存人陪信息 <pre>  /plan : obe_cultivation_plan、obe_plan_class（人培班级关系表）</pre> </li>
</ul>
</li>
<li>培养目标 <ul>
<li>提交培养目标 <pre>  /goals/status : obe_plan_status </pre>  </li>
<li>保存培养目标拆分点 <pre>  /goals/split : obe_goals （培养目标关系表）、obe_goals_split （培养目标拆解表）</pre> </li>
<li>保存培养目标 <pre> /goals : obe_goals </pre> </li>
</ul>
</li>
<li>毕业要求 <ul>
<li>保存毕业要求  <pre> /graduate : obe_graduate (毕业要求表)</pre> </li>
<li>保存拆解指标点 <pre>  graduate/split : obe_graduate 、obe_graduate_split(毕业要求拆解表)</pre> </li>
<li>提交毕业要求  <pre> /graduate/status/{planCode} : obe_plan_status </pre> </li>
<li>查询毕业要求模板信息 <pre>  /graduate/templates : obe_graduate_template (毕业要求模板表)</pre> </li>
<li>查询毕业要求信息 <pre>  /graduate/info : obe_graduate 、obe_graduate_split </pre> </li>
<li>查询毕业要求支撑矩阵 <pre>  /graduate/split/matrix/{planCode} : obe_graduate_split、obe_graduate、obe_goals_graduate_weight（课程体系与毕业要求权重矩阵）、obe_goals、obe_goals_split </pre> </li>
<li>保存毕业要求支撑矩阵的权重  <pre>  /graduate/split/matrix/weight : obe_goals_graduate_weight </pre> </li>
</ul>
</li>
<li>课程体系 <ul>
<li>保存课程体系 <pre>  /courseSystem : obe_course_system (课程体系表) </pre> </li>
<li>查询课程体系 <pre>  /courseSystemList/{planCode} : obe_course_system 、obe_cultivation_plan </pre> </li>
<li>查询课程体系统计信息 <pre> /courseSystem/statistics/{planCode} : obe_course_system </pre></li>
<li>查询课程体系支撑矩阵 <pre> /courseSystem/matrix/{planCode} : obe_graduate_split、obe_graduate、obe_course_graduate_weight（课程体系与毕业要求权重矩阵）、obe_course_system、obe_cultivation_plan  </pre></li>
<li>保存课程体系支撑矩阵的权重 <pre> /courseSystem/matrix/weight : obe_course_graduate_weight</pre></li>
</ul>
</li>
<li>毕业条件<ul>
<li>保存扩展信息 <pre> /planCertificate/extra : obe_plan_extra (人培方案毕业条件)</pre></li>
<li>查询扩展信息 <pre> /planCertificate/extra/info/{planCode} : obe_plan_extra</pre></li>
<li>保存取证要求 <pre> /planCertificate : obe_plan_certificate (人陪需要证书表)</pre></li>
</ul>
</li>
<li>其他说明<ul>
<li><strong>同毕业条件</strong></li>
</ul>
</li>
</ul>
</li>
<li>如图 :</li>
<li><img src="https://imgur.com/INaUOdV.png" alt=""><h2 id="2022年5月16日-工作日志"><a href="#2022年5月16日-工作日志" class="headerlink" title="2022年5月16日 工作日志"></a>2022年5月16日 工作日志</h2><h3 id="达成目标-1"><a href="#达成目标-1" class="headerlink" title="达成目标"></a>达成目标</h3></li>
<li>将课程大纲模板问题解决</li>
<li>泳道图设计<h3 id="问题或建议-1"><a href="#问题或建议-1" class="headerlink" title="问题或建议"></a>问题或建议</h3></li>
</ul>
<ol>
<li>课程大纲编辑选择人才方案为空，应该有问题 待改进。</li>
<li><h3 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h3></li>
</ol>
<h3 id="课程大纲管理如下图"><a href="#课程大纲管理如下图" class="headerlink" title="课程大纲管理如下图"></a>课程大纲管理如下图</h3><p><img src="https://i.imgur.com/0u8twIb.png" alt=""></p>
<h2 id="2022年5月17日-工作日志"><a href="#2022年5月17日-工作日志" class="headerlink" title="2022年5月17日 工作日志"></a>2022年5月17日 工作日志</h2><h3 id="问题或建议-2"><a href="#问题或建议-2" class="headerlink" title="问题或建议"></a>问题或建议</h3><ol>
<li>查看教学研讨接口报错 <h3 id="教学过程管理如图"><a href="#教学过程管理如图" class="headerlink" title="教学过程管理如图"></a>教学过程管理如图</h3><img src="https://i.imgur.com/mCiYNzl.png" alt=""><h2 id="2022年5月18日-工作日志"><a href="#2022年5月18日-工作日志" class="headerlink" title="2022年5月18日 工作日志"></a>2022年5月18日 工作日志</h2><h3 id="有联系的表的相关图"><a href="#有联系的表的相关图" class="headerlink" title="有联系的表的相关图"></a>有联系的表的相关图</h3><img src="https://imgur.com/OXY4JGB.png" alt=""></li>
</ol>
<h3 id="接下来要做的"><a href="#接下来要做的" class="headerlink" title="接下来要做的"></a>接下来要做的</h3><ul>
<li>验证这个有联系的表之间知否做到了数据的互通。<ul>
<li>obe_cultivation_plan 通<h3 id="obe问题"><a href="#obe问题" class="headerlink" title="obe问题"></a>obe问题</h3><h4 id="人才培养方案-1"><a href="#人才培养方案-1" class="headerlink" title="人才培养方案"></a>人才培养方案</h4></li>
</ul>
</li>
</ul>
<ol>
<li><del> 课程体系接口有点慢 </del></li>
<li>毕业条件接口存在循环调用问题</li>
<li>课程体系查询存在重复查询问题 planCode = PL202204071119520566</li>
<li>提交毕业要求接口（/graduate/status/）权重配置错误的情况 未正确返回提示。</li>
<li>毕业条件页面 如果保存的列表为空，则无法切换其他页面并且没有提示</li>
<li>毕业条件删除没有提示。</li>
<li>人陪列表学院筛选失败<h4 id="课程大纲管理"><a href="#课程大纲管理" class="headerlink" title="课程大纲管理"></a>课程大纲管理</h4></li>
<li>点击新建课程大纲，查询单个课程体系接口报错（405）前端传参错误造成</li>
<li>保存成功没有前端提示</li>
<li>基本信息课程下拉double 需要改</li>
<li>考核方案  设计说明 保存不上</li>
<li>课程大纲列表删除没反应</li>
<li>提交审核之后不自动刷新列表</li>
<li>课程大纲管理列表学院筛选失败<h4 id="教学过程管理"><a href="#教学过程管理" class="headerlink" title="教学过程管理"></a>教学过程管理</h4></li>
</ol>
<ul>
<li>资料管理 下载失败！</li>
</ul>
]]></content>
      <categories>
        <category>wordhard</category>
      </categories>
      <tags>
        <tag>workharding</tag>
      </tags>
  </entry>
</search>
