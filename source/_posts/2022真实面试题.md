---
title: 2022真实面试题整理
type:
  - 技术
tags: 技术
categories: 技术
comments: true
abbrlink: d98d9db3
date: 2022-05-31 00:00:00
---
### 在一场面试中你会被问到什么取决于下面这些因素：
- 你的经验
- 你的技术背景
- 你面试的职位
- 你面试的公司
- 运气
<!--more-->
### explain各个字段代表的意思
- id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
- select_type ：查询类型 或者是 其他操作类型
- table ：正在访问哪个表
- partitions ：匹配的分区
- type ：访问的类型
- possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到
- key ：实际使用到的索引，如果为NULL，则没有使用索引
- key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
- ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值
- rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数
- filtered ：查询的表行占表的百分比
- Extra ：包含不适合在其它列中显示但十分重要的额外信息

### mysql的锁
### 页面相应慢,从哪几方面入手处理
### 大数据量之间同步,从哪几方面做优化处理 减少服务器及数据库压力

### redis的几种集群模式及区别
  - https://cloud.tencent.com/developer/article/1751001
  - 主从模式
    - 1个master，两个slave
    - 主从复制的优缺点
        - 优点：
          - 读写分离
        - 缺点：

          - 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
          - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
          - 难以支持在线扩容，Redis的容量受限于单机配置
  - 哨兵模式
    - 一个master、两个slave、三个sentinel
    - 哨兵模式的优缺点
        优点：

        - 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
        - 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
        缺点：

        - 同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置
        - 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务
  - Cluster模式
    - 3主节点3从节点
### redis 为什么快
  - 完全基于内存，数据存在内存中
  - 采用单线程，省去了很多上下文切换的时间以及CPU消耗
  - 使用基于IO多路复用机制的线程模型，可以处理并发的链接
### mysql 和 redis 的双写问题: 
- redis先写  写成功 mysql 没写成功
- mysql 先写 redis 都没成功 数据库压力大 怎么解决
###  dubbo 和 springcloud的区别?
  - https://juejin.cn/post/7059400668036988964
  - springcloud 不是一个开发框架，而是一整套的解决方案，而 dubbo 仅仅是一个 rpc 的框架。

    - dubbo 采用的是传输层 tcp 协议，是二进制传输的，占用带宽较少，序列化采用的是 jdk 自带的序列化协议。springcloud 是应用层 http 协议，占用带宽比较多，同时 springcloud 采用的是 json 报文传输，消耗会比较大。
    - dubbo 调用使用的是长链接，适合传输数据量小的包，而对于 springcloud 是短连接，适合传输大数据量的信息，比如图片、文本之类的。
    - dubbo 开发需要依赖 jar 包，对依赖的管理比较复杂。springcloud 的接口协议比较松散，约束性不强。
    - 关于 dubbo 和 springcloud 的提供的服务功能差异如下图所示：
    - | 功能名称 | Dubbo | spring cloud |
      | --- | ---| --- |
      | 服务注册中心 | ZooKeeper | Spring Cloud Netflix Eureka |
      | 服务调用方式 | RPC | REST API |
      | 服务网关 | 无 | Spring Cloud Netflix Zuul |
      | 断路器 | 不完善 | Spring Cloud Netflix Hystrix|
      | 分布式配置 | 无 | Spring Cloud Config|
      | 服务跟踪 | 无 | Spring Cloud Sleuth |
      | 消息总线 | 无 | Spring Cloud Bus|
      | 数据流 | 无 | Spring Cloud Stream | 
      | 批量任务 | 无 | Spring Cloud Task |
    - 注册中心使用的不同，dubbo 默认使用的是 zk, 而 springcloud 使用的注册中心为 eureka, 前者保证的是 cp ,而后者保证的是 ap, 但是随着 springcloud alibaba 的出现，又引入了 nacos 这样的神器，兼有注册中心和配置中心的功能
### 什么是feign？它的优点是什么？
1. feign采用的是基于接口的注解
2. feign整合了ribbon，具有负载均衡的能力
3. 整合了Hystrix，具有熔断的能力
- 使用:
1. 添加pom依赖。
2. 启动类添加@EnableFeignClients
3. 定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务
### zookeeper 和 eureka 的区别?
- CAP 理论 
- eureka AP 
- zookeeper CP
### 用没用过nacos , spring cloud 如何使用的 ?
### spring cloud 你用过那些组件?
- Eureka （注册中心）
- Zuul (服务网关)
- Ribbon (负载均衡)
- Hystrix （熔断保护器）隔离、熔断以及降级
- Feign （Rest转换器）
- Config （分布式配置管理）
### 谈谈注册中心 zookeeper 和 eureka中的CP和 AP
  - eureka AP
    - eureka 保证了可用性，实现最终一致性。

    - Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)，其中说明了，eureka是不满足强一致性，但还是会保证最终一致性

  - zookeeper CP
    - zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用，但是在选举成功之后，因为一主多从的结构，zookeeper在这时还是一个高可用注册中心，只是在优先保证一致性的前提下，zookeeper才会顾及到可用性
### 有多线程开发经验吗?了解过线程池吗,说一下线程池的使用
- TreadPoolExecutor的7个参数
  1. corePoolSize 
  2. maximumPoolSize
  3. keepAliveTime
  4. unit
  5. workQueue
  6. threadFactory
  7. handler
### gc 的回收原理
- 简述下gc 回收的过程便可。
### cms 和 G1 的主要区别?
- CMS收集器优点：、
  - 并发收集、低停顿。

- CMS收集器缺点：
  - CMS收集器对CPU资源非常敏感。
  - CMS收集器无法处理浮动垃圾（Floating Garbage）。
  - CMS收集器是基于标记-清除算法，该算法的缺点都有。
- G1具备如下特点：

  - 并行与并发：
    - G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。
  - 分代收集
    - 空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
  - 可预测的停顿：
    - 这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。
### 可达性分析算法 哪些对象可以作为GC root ?
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象；
2. 方法区中的类静态属性引用的对象；
3. 方法区中常量引用的对象；
4. 本地方法栈中JNI（即一般说的Native方法）中引用的对象
- JVM 原理的几大组成部分
### mysql 索引存储结构
  - b+tree
### spring 生命周期
- 实例化 -> 属性赋值 -> 初始化 -> 销毁
### spring bean的作用域 
- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
- session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
- global-session： 全局 session 作用域，
### 一些技术点
- nacos ： spring cloud alibaba 下的注册中心和配置中心 

## RabbitMQ相关
### 优点
- 异步 : 比如发短信调用三方的接口，使用mq，发送到mq中就代表成功发送，不需要等待接口实时返回结果
- 解耦 ：系统A对接多个系统，不需要单独对接，只需要将需要对接的数据发送到mq中便可以，需要对接的系统自己去mq里消费便可以了。
- 流量削峰：某一时刻，系统并发量突然提高，这时候直接写库会造成数据库压力过大，在数据库和请求之间使用mq，将请求的数据直接发到mq中进行缓存，然后根据mq的队列顺序入库
### 缺点
- 系统可用性降低。
- 系统复杂度提高，随之带来几个问题
  - 怎么保证消息没有重复消费？
  - 怎么处理消息丢失的情况？
  - 保证消息传递的顺序性 ？
### 主流MQ对比
- 吞吐量
  - kafka、RocketMQ高吞吐，ActiveMQ、RabbitMQ比他们低一个数量级。
- RabbitMQ是延迟最低的。
- 社区活跃度
  -  RabbitMQ 最高。
- 持久化消息 ：ActiveMq 和RabbitMq 都支持
  - 持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。
- 综合技术实现
  - 可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。RabbitMq 、 Kafka 最好，ActiveMq 次之
- 高并发 
  - RabbitMQ 最好，原因是它的实现语言是天生具备高并发高可用的erlang 语言。
### RabbitMQ 和 Kafka
- 在可用性上，稳定性上，可靠性上，RabbitMq 比 Kafka 成熟（理论上）。
- Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件
- 业务方面还是建议选择 RabbitMq 。
### 怎么解决消息重复消费问题？
- 消费端解决，业务实现幂等性
- 生产端消息入队需要有消息的唯一ID（保单号，生产端发送消息并不能保证保单号唯一），
- 入库前根据唯一ID去数据库中校验是否存在，如果存在则不入库。否则入库。
  - 保单号，生产端发送消息并不能保证保单号唯一 带来的并发消费问题
  - 解决方法使用redis 分布式锁，利用setnx特性，获取到锁后再进行入库。
### 如何解决消息丢失问题？
####  生产者丢失数据
- RabbitMQ 提供事务功能，就是生产者发送数据之前开启 RabbitMQ 事务。然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错。但吞吐量会降低，因为太耗性能（同步）。
- 开启confirm机制，每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，异步回调你，告诉你这个消息 ok 了。
  - 事务机制是同步的，confirm机制是异步的，发送个消息之后就可以发送下一个消息，RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。所以用confirm机制
#### RabbitMQ 弄丢了数据
- RabbitMQ 自己挂掉导致数据丢失

- 开启 RabbitMQ 的持久化，消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据

#### 消费端弄丢了数据
- RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，RabbitMQ 认为你都消费了，这数据就丢了。

- 关闭 RabbitMQ 的自动ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。
- 

### 消息顺序性
- 消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。

- 消息体通过hash分派到队列里，每个队列对应唯一一个消费者。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：

![](https://github.com/xbox1994/Java-Interview/raw/master/images/消息顺序性.jpg)

- 在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个订单号获取到的肯定是同一个队列。

## JUC面试题
### 什么是线程？
- 一个程序里不同的执行路径
### 线程的启动方式
- 继承thread 类 并调用start方法
- 实现Runable接口 然后通过new Thread（实现类）.start() 或 lambda 方法调用
- 通过线程池启动
### 线程的集中等待的方式
- sleep 休眠一段时间，休眠结束后进入就绪态
- yield 直接进入就绪态
- join 将自身线程加入另一个线程，另一个线程结束后 直接运行自身这个线程。
- wait 进入阻塞态，等待被叫醒，叫醒后进入就绪态。
### 线程的六个状态？
- NEW 线程创建未执行
- RUNNABLE 线程就绪或者执行
- TERMINATED 线程正常结束
- TIMEDWAITING  等待进入就绪的状态
- WAITING 等待被叫醒的状态
- BLOCKED 阻塞状态 等待获取锁。
### synchronized
- synchronized （this） 和 synchronized 方法其实是一样的
- synchronized(Object) 
  - 不能用String常量 Interger Long 
  - object
  - 锁的是对象 不是代码
  - this XX.class
  - 锁升级 :  偏向锁、自旋锁、重量级锁（OS）--> 是轻量到重量的一个过程
    - 执行时间短的用自旋锁
    - 执行时间长的用重量级锁
### 什么是并发？什么是并行？
- 在固定时间内将多个线程平均分配该资源可以称为并发，每个线程执行是其余线程需要等待 简单说就是一个小时 12个学生 每五分钟一个学生可以向老师提问
- 并行就是在五分钟内 可以有多个学生同时向老师提问。
- 短的时间片叫并行。长时间片叫并发。
### 并发与并行会造成什么影响？
- 死锁 ： 如何解决？ 答：保证同一时间只有一个线程可以处理当前事务，线程互斥。
### 如何解决这些影响？
- 管程（程序管理）
- 加锁
### 操作系统基本概念说一下?
- finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 Java中所有类都从Object类中继承finalize()方法。 当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法

### volatile 只针对变量
- 可以解决操作系统重排序
  - 分配内存空间
  - 初始化对象
  - 将对象地址赋值给引用
- 解决线程共享变量之间的可见性
- 解决单次读/写的原子性
- AQS
- CAS : 并发包 atomic包下的包装类运用的cas机制  